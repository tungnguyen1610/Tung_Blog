<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>T_Blog</title><link href="https://tungnguyen1610.github.io/Tung_Blog/" rel="alternate"></link><link href="https://tungnguyen1610.github.io/Tung_Blog/feeds/all-en.atom.xml" rel="self"></link><id>https://tungnguyen1610.github.io/Tung_Blog/</id><updated>2025-05-10T00:00:00+07:00</updated><entry><title>FPGA Basics</title><link href="https://tungnguyen1610.github.io/Tung_Blog/digital-design/fpga-basics.html" rel="alternate"></link><published>2025-05-10T00:00:00+07:00</published><updated>2025-05-10T00:00:00+07:00</updated><author><name>Tung Nguyen</name></author><id>tag:tungnguyen1610.github.io,2025-05-10:/Tung_Blog/digital-design/fpga-basics.html</id><summary type="html">&lt;p&gt;Introduction to FPGA development and applications.&lt;/p&gt;</summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;Field-Programmable Gate Arrays (FPGAs) are integrated circuits that can be configured by the user after manufacturing...&lt;/p&gt;</content><category term="Digital Design"></category><category term="fpga"></category><category term="verilog"></category><category term="hardware"></category></entry><entry><title>General Concepts in Digital Design</title><link href="https://tungnguyen1610.github.io/Tung_Blog/digital-design/general-digital-design.html" rel="alternate"></link><published>2025-05-10T00:00:00+07:00</published><updated>2025-05-10T00:00:00+07:00</updated><author><name>Tung Nguyen</name></author><id>tag:tungnguyen1610.github.io,2025-05-10:/Tung_Blog/digital-design/general-digital-design.html</id><summary type="html">&lt;p&gt;Combinational logic and sequential logic&lt;/p&gt;</summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h2&gt;Timing Basics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Setup Time&lt;/strong&gt;: Time input must be stable &lt;strong&gt;before&lt;/strong&gt; clock edge.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hold Time&lt;/strong&gt;: Time input must be stable &lt;strong&gt;after&lt;/strong&gt; clock edge.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aperture Time&lt;/strong&gt;: &lt;code&gt;Setup + Hold&lt;/code&gt; time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Recovery Time&lt;/strong&gt;: Time async reset/set must be &lt;strong&gt;inactive before&lt;/strong&gt; clock edge.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Removal Time&lt;/strong&gt;: Time async reset/set must be &lt;strong&gt;inactive after&lt;/strong&gt; clock edge.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Metastability&lt;/strong&gt;: Flip-flops enter unpredictable states if timing is violated.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fanout&lt;/strong&gt;: Number of gate inputs driven by a logic output.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Combinational Logic&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hazard&lt;/strong&gt;: Glitches in outputs due to gate delays and improper logic design.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Finite State Machines (FSM)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Encoding Styles&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Binary&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gray&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;One-hot&lt;/strong&gt;: One bit is HIGH, others LOW.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;One-cold&lt;/strong&gt;: One bit is LOW, others HIGH.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Clock Domain Crossing (CDC)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Transferring data between &lt;strong&gt;different clock domains&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Prevent metastability using:&lt;/li&gt;
&lt;li&gt;2/3 stage synchronizers&lt;/li&gt;
&lt;li&gt;To be added.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Digital Design"></category></entry><entry><title>SystemVerilog Coding Essentials</title><link href="https://tungnguyen1610.github.io/Tung_Blog/digital-design/systemverilog-coding-essentials.html" rel="alternate"></link><published>2025-05-10T00:00:00+07:00</published><updated>2025-05-10T00:00:00+07:00</updated><author><name>Tung Nguyen</name></author><id>tag:tungnguyen1610.github.io,2025-05-10:/Tung_Blog/digital-design/systemverilog-coding-essentials.html</id><summary type="html">&lt;p&gt;SystemVerilog concepts including assignments, procedures, and language features.&lt;/p&gt;</summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h2&gt;Assignments in SystemVerilog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Blocking Assignment (&lt;code&gt;=&lt;/code&gt;)&lt;/strong&gt;: Executes sequentially.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Non-Blocking Assignment (&lt;code&gt;&amp;lt;=&lt;/code&gt;)&lt;/strong&gt;: All updates scheduled at end of time step.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Types of Assignments&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Procedural Assignments&lt;/strong&gt;: Used in &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt;, &lt;code&gt;task&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Continuous Assignments&lt;/strong&gt;: Assigned directly to &lt;code&gt;wire&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;case&lt;/code&gt; must be used &lt;strong&gt;within procedural blocks&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;SystemVerilog Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Classes &amp;amp; Inheritance&lt;/strong&gt;: For OOP-style modeling.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Randomization&lt;/strong&gt;: Use &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;constraint&lt;/code&gt; for random test generation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bit Ordering&lt;/strong&gt;: &lt;code&gt;[2:0]&lt;/code&gt; means MSB (&lt;code&gt;2&lt;/code&gt;) to LSB (&lt;code&gt;0&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Modules&lt;/h2&gt;
&lt;p&gt;```systemverilog
module example (
  input logic clk,
  input logic rst,
  output logic [2:0] out
);
// ...
endmodule&lt;/p&gt;</content><category term="Digital Design"></category></entry><entry><title>Intro to Embedded Linux</title><link href="https://tungnguyen1610.github.io/Tung_Blog/embedded-systems/intro-to-embedded-linux.html" rel="alternate"></link><published>2025-05-09T00:00:00+07:00</published><updated>2025-05-09T00:00:00+07:00</updated><author><name>Tung Nguyen</name></author><id>tag:tungnguyen1610.github.io,2025-05-09:/Tung_Blog/embedded-systems/intro-to-embedded-linux.html</id><summary type="html">&lt;p&gt;Learn the basics of Embedded Linux boot-up using Beaglebone Black.&lt;/p&gt;</summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Why is Linux so pervasive? Why does something as seemingly simple as a smart TV need to run something as complex as Linux just to stream video?&lt;/p&gt;
&lt;p&gt;The answer is functionality. Linux is open-source, and it offers a robust scheduler, a powerful networking stack, support for USB, Wi-Fi, Bluetooth, various storage types, multimedia devices, and much more. It checks all the boxes needed in a modern embedded device.&lt;/p&gt;
&lt;p&gt;In this article, we'll explore the &lt;strong&gt;startup process&lt;/strong&gt; of an embedded Linux system, using the well-known &lt;strong&gt;Beaglebone Black&lt;/strong&gt; as an example. Devices like the Raspberry Pi follow a similar boot process, so these principles apply across many embedded platforms.&lt;/p&gt;
&lt;p&gt;For a deeper dive into every layer of Embedded Linuxâ€”from bootloader to kernel, device trees, and driver developmentâ€”I recommend the book &lt;strong&gt;"Mastering Embedded Linux Programming"&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;1. Boot Process Overview&lt;/h2&gt;
&lt;p&gt;The boot process of an embedded Linux system typically involves the following stages:&lt;/p&gt;
&lt;h3&gt;ðŸ”¹ Phase 1: ROM Code (Primary Bootloader)&lt;/h3&gt;
&lt;p&gt;This is the very first code that runs after power-on or reset. It is stored &lt;strong&gt;on-chip&lt;/strong&gt; in the SoC and is called &lt;strong&gt;ROM code&lt;/strong&gt;. Its job is to load a small portion of code from pre-defined sources into &lt;strong&gt;SRAM&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;For example, Texas Instruments (TI) Sitara and OMAP processors may attempt to load this code (commonly named &lt;code&gt;MLO&lt;/code&gt;) from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAND flash&lt;/li&gt;
&lt;li&gt;SPI-connected flash&lt;/li&gt;
&lt;li&gt;MMC devices like eMMC or SD cards&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once loaded into SRAM, the ROM code jumps to the &lt;strong&gt;SPL (Secondary Program Loader)&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;ðŸ”¹ Phase 2: MLO (Secondary Bootloader)&lt;/h3&gt;
&lt;p&gt;This second-stage bootloader configures basic hardware like the memory controller. It then reads &lt;code&gt;u-boot.img&lt;/code&gt; from a partition and prepares the system to run a full bootloader (U-Boot).&lt;/p&gt;
&lt;h4&gt;ðŸ“¦ Example: Flashing from SD Card to eMMC on TI AM3358&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;#debug_over_display=tty0&lt;/span&gt;
&lt;span class="nv"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/mmcblk0
&lt;span class="nv"&gt;destination&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/mmcblk1
&lt;span class="nv"&gt;rfs_partition&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;single
&lt;span class="nv"&gt;rfs_rootfs_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;ext4
&lt;span class="nv"&gt;rfs_rootfs_startmb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;
&lt;span class="nv"&gt;bootloader&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/u-boot/bb-u-boot-am57xx-evm/install-mmcblk1.sh
&lt;span class="nv"&gt;flash_back&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;bbai-emmc-to-microsd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;ðŸ”¹ Phase 3: Full bootloader&lt;/h3&gt;
&lt;p&gt;At this stage, a full bootloader such as U-Boot is running. Its role is to:
- Load the Linux kernel into DRAM
- Pass essential information to the kernel&lt;/p&gt;
&lt;p&gt;This includes:
- Hardware details, including: based address, working mode, interrupt line, etc.
- Kernel command-line arguments
Optional:
- Device Tree Blob (DTB): Describes hardware layout (memory, I/O, interrupts, etc.)
- Initial RAM filesystem (initramfs)&lt;/p&gt;
&lt;p&gt;The kernel uses this information to initialize drivers and mount the root filesystem.&lt;/p&gt;</content><category term="Embedded Systems"></category><category term="Beaglebone Black"></category><category term="SoC"></category><category term="Linux"></category><category term="Bootloader"></category></entry><entry><title>Intro to STM32</title><link href="https://tungnguyen1610.github.io/Tung_Blog/embedded-systems/intro-to-stm32.html" rel="alternate"></link><published>2025-05-09T00:00:00+07:00</published><updated>2025-05-09T00:00:00+07:00</updated><author><name>Tung Nguyen</name></author><id>tag:tungnguyen1610.github.io,2025-05-09:/Tung_Blog/embedded-systems/intro-to-stm32.html</id><summary type="html">&lt;p&gt;Learn STM32 basics.&lt;/p&gt;</summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;STM32 is a family of 32-bit microcontrollers developed by STMicroelectronics...&lt;/p&gt;</content><category term="Embedded Systems"></category><category term="stm32"></category><category term="microcontroller"></category></entry><entry><title>STM32 Startup Sequence</title><link href="https://tungnguyen1610.github.io/Tung_Blog/embedded-systems/stm32-startup-sequence.html" rel="alternate"></link><published>2025-05-09T00:00:00+07:00</published><updated>2025-05-09T00:00:00+07:00</updated><author><name>Tung Nguyen</name></author><id>tag:tungnguyen1610.github.io,2025-05-09:/Tung_Blog/embedded-systems/stm32-startup-sequence.html</id><summary type="html">&lt;p&gt;Understand the power-on and startup sequence of STM32 microcontrollers.&lt;/p&gt;</summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In this article, we'll explore how an STM32 microcontroller starts up after power-on or reset â€” from the first instruction to the start of your &lt;code&gt;main()&lt;/code&gt; function.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Microcontroller Startup Basics&lt;/h2&gt;
&lt;p&gt;A microcontroller begins execution from a known &lt;strong&gt;reset vector address&lt;/strong&gt;. For ARM Cortex-M cores (used in STM32 devices), this involves the &lt;strong&gt;Interrupt Vector Table (IVT)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IVT Location&lt;/strong&gt;: At the start of the memory map (e.g., &lt;code&gt;0x08000000&lt;/code&gt; for Flash)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;First Entry&lt;/strong&gt;: Initial &lt;strong&gt;Stack Pointer&lt;/strong&gt; (SP)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Second Entry&lt;/strong&gt;: Address of the &lt;strong&gt;Reset Handler&lt;/strong&gt; (i.e., where execution starts)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These values are set by the &lt;strong&gt;linker script&lt;/strong&gt; and provided in &lt;code&gt;stm32xxx_flash.ld&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;STM32 Startup Sequence&lt;/h2&gt;
&lt;p&gt;Hereâ€™s the typical STM32 boot and startup process:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Reset Handler&lt;/strong&gt; (2nd entry in the IVT) is called&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Boot Configuration&lt;/strong&gt;: Determines whether to boot from:&lt;/li&gt;
&lt;li&gt;Flash (default for user code)&lt;/li&gt;
&lt;li&gt;System memory (bootloader)&lt;/li&gt;
&lt;li&gt;SRAM (for debugging/testing)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SystemInit()&lt;/strong&gt; is usually called (by CMSIS) early to:&lt;/li&gt;
&lt;li&gt;Set up clock sources (HSE/PLL)&lt;/li&gt;
&lt;li&gt;Configure low-level registers (via &lt;code&gt;system_stm32fxxx.c&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C Runtime Initialization&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Section Init&lt;/strong&gt;: Copies initialized variables from Flash to RAM&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BSS Section Init&lt;/strong&gt;: Zeros out uninitialized global/static variables&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Static Constructors&lt;/strong&gt;: Run C++ constructors if any&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main()&lt;/code&gt; function is finally called&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2&gt;Visual Summary&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[Power On / Reset]
       â†“
[IVT @ 0x08000000]
  - SP (entry 0)
  - Reset_Handler (entry 1)
       â†“
[SystemInit()]
       â†“
[Initialize .data and .bss]
       â†“
[Run static constructors]
       â†“
[main()]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="Embedded Systems"></category><category term="stm32"></category><category term="microcontroller"></category><category term="startup"></category><category term="reset"></category><category term="IVT"></category></entry></feed>